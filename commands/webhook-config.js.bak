const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const webhookLogger = require('../utils/webhookLogger');
const configManager = require('../utils/configManager');

module.exports = {
    data: new SlashCommandBuilder()
        .setName('webhook-config')
        .setDescription('üîó Configuration avanc√©e du syst√®me de webhooks pour les logs')
        .setDefaultMemberPermissions('8'), // Administrator permission
        
    async execute(interaction) {
        if (!interaction.member.permissions.has('Administrator')) {
            return interaction.reply({
                content: '‚ùå Vous devez √™tre administrateur pour utiliser cette commande.',
                ephemeral: true
            });
        }

        await interaction.deferReply({ ephemeral: true });

        try {
            const status = webhookLogger.getStatus();
            const webhookConfig = configManager.getWebhookConfig();

            const embed = new EmbedBuilder()
                .setTitle('üîó Configuration des Webhooks')
                .setDescription('**Syst√®me de logs moderne avec webhooks**\n\nLes webhooks offrent de meilleures performances et un design plus professionnel pour vos logs.')
                .setColor('#3182CE')
                .addFields(
                    {
                        name: 'üìä Statut G√©n√©ral',
                        value: `\`\`\`yaml\nWebhooks actifs: ${status.webhooksActive}\nMode fallback: ${status.fallbackMode ? 'Activ√©' : 'D√©sactiv√©'}\nTypes disponibles: ${status.types.length}\`\`\``,
                        inline: false
                    },
                    {
                        name: 'üé® Types de Logs Disponibles',
                        value: status.types.map(type => {
                            const hasWebhook = Object.hasOwnProperty.call(webhookConfig, type);
                            const emoji = hasWebhook ? '‚úÖ' : '‚ùå';
                            return `${emoji} **${type}**`;
                        }).join('\n'),
                        inline: true
                    },
                    {
                        name: 'üöÄ Avantages des Webhooks',
                        value: '‚Ä¢ **Performance** am√©lior√©e\n‚Ä¢ **Design** professionnel\n‚Ä¢ **Avatars** personnalis√©s\n‚Ä¢ **Rate limits** s√©par√©s\n‚Ä¢ **Flexibilit√©** maximale',
                        inline: true
                    }
                )
                .setFooter({ 
                    text: 'üí° Utilisez les boutons pour g√©rer vos webhooks', 
                    iconURL: interaction.client.user.displayAvatarURL() 
                })
                .setTimestamp();

            // Boutons d'action
            const row1 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('webhook_setup_all')
                        .setLabel('üöÄ Configurer Automatiquement')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('webhook_status')
                        .setLabel('üìä Statut D√©taill√©')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('webhook_test')
                        .setLabel('üß™ Test Webhooks')
                        .setStyle(ButtonStyle.Secondary)
                );

            const row2 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('webhook_refresh')
                        .setLabel('üîÑ Actualiser')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('webhook_cleanup')
                        .setLabel('üóëÔ∏è Nettoyer')
                        .setStyle(ButtonStyle.Danger)
                );

            const response = await interaction.editReply({
                embeds: [embed],
                components: [row1, row2]
            });

            // Collector pour les interactions
            const collector = response.createMessageComponentCollector({
                filter: i => i.user.id === interaction.user.id,
                time: 300000 // 5 minutes
            });

            collector.on('collect', async i => {
                try {
                    await i.deferUpdate();

                    switch (i.customId) {
                        case 'webhook_setup_all':
                            await setupAllWebhooks(i);
                            break;
                        case 'webhook_status':
                            await showDetailedStatus(i);
                            break;
                        case 'webhook_test':
                            await testWebhooks(i);
                            break;
                        case 'webhook_refresh':
                            await refreshWebhooks(i);
                            break;
                        case 'webhook_cleanup':
                            await cleanupWebhooks(i);
                            break;
                    }
                } catch (error) {
                    console.error('[WEBHOOK CONFIG] Erreur:', error);
                    if (!i.replied) {
                        await i.followUp({
                            content: '‚ùå Une erreur est survenue lors du traitement.',
                            ephemeral: true
                        });
                    }
                }
            });

            collector.on('end', async () => {
                try {
                    const disabledRows = [row1, row2].map(row => {
                        const newRow = new ActionRowBuilder();
                        row.components.forEach(component => {
                            newRow.addComponents(
                                ButtonBuilder.from(component).setDisabled(true)
                            );
                        });
                        return newRow;
                    });

                    await interaction.editReply({ components: disabledRows });
                } catch (error) {
                    console.error('[WEBHOOK CONFIG] Erreur d√©sactivation boutons:', error);
                }
            });

        } catch (error) {
            console.error('[WEBHOOK CONFIG] Erreur principale:', error);
            await interaction.editReply({
                content: '‚ùå Une erreur est survenue lors du chargement de la configuration webhook.',
                embeds: [],
                components: []
            });
        }
    }
};

async function setupAllWebhooks(interaction) {
    try {
        await webhookLogger.initialize(interaction.client);
        
        const embed = new EmbedBuilder()
            .setTitle('üöÄ Configuration Automatique')
            .setDescription('**Webhooks configur√©s avec succ√®s !**\n\nTous les webhooks ont √©t√© cr√©√©s automatiquement pour vos canaux de logs.')
            .setColor('#38A169')
            .addFields({
                name: '‚úÖ R√©sultat',
                value: 'Le syst√®me de logs moderne est maintenant actif.',
                inline: false
            })
            .setTimestamp();

        await interaction.followUp({
            embeds: [embed],
            ephemeral: true
        });

    } catch (error) {
        await interaction.followUp({
            content: '‚ùå Erreur lors de la configuration automatique des webhooks.',
            ephemeral: true
        });
    }
}

async function showDetailedStatus(interaction) {
    const status = webhookLogger.getStatus();
    const webhookConfig = configManager.getWebhookConfig();

    const embed = new EmbedBuilder()
        .setTitle('üìä Statut D√©taill√© des Webhooks')
        .setColor('#3182CE');

    let statusText = '';
    for (const type of status.types) {
        const hasWebhook = Object.hasOwnProperty.call(webhookConfig, type);
        const icon = hasWebhook ? 'üü¢' : 'üî¥';
        statusText += `${icon} **${type}**: ${hasWebhook ? 'Configur√©' : 'Non configur√©'}\n`;
    }

    embed.addFields({
        name: 'üîó √âtat des Webhooks',
        value: statusText,
        inline: false
    });

    await interaction.followUp({
        embeds: [embed],
        ephemeral: true
    });
}

async function testWebhooks(interaction) {
    try {
        // Test des diff√©rents types de webhooks
        await webhookLogger.log('moderation', new EmbedBuilder()
            .setTitle('üß™ Test Webhook Mod√©ration')
            .setDescription('Ceci est un test du webhook de mod√©ration.')
            .setColor('#E53E3E')
        );

        await webhookLogger.log('messages', new EmbedBuilder()
            .setTitle('üß™ Test Webhook Messages')
            .setDescription('Ceci est un test du webhook de messages.')
            .setColor('#3182CE')
        );

        await webhookLogger.log('messagesEdited', new EmbedBuilder()
            .setTitle('üß™ Test Webhook Messages √âdit√©s')
            .setDescription('Ceci est un test du webhook de messages √©dit√©s.')
            .setColor('#FFA500')
        );

        await webhookLogger.log('messagesDeleted', new EmbedBuilder()
            .setTitle('üß™ Test Webhook Messages Supprim√©s')
            .setDescription('Ceci est un test du webhook de messages supprim√©s.')
            .setColor('#FF0000')
        );

        await interaction.followUp({
            content: 'üß™ **Tests envoy√©s !**\n\nV√©rifiez vos canaux de logs pour voir les messages de test.',
            ephemeral: true
        });

    } catch (error) {
        await interaction.followUp({
            content: '‚ùå Erreur lors des tests webhook.',
            ephemeral: true
        });
    }
}

async function refreshWebhooks(interaction) {
    try {
        await webhookLogger.initialize(interaction.client);
        
        await interaction.followUp({
            content: 'üîÑ **Webhooks actualis√©s !**\n\nLe syst√®me a √©t√© recharg√© avec succ√®s.',
            ephemeral: true
        });

    } catch (error) {
        await interaction.followUp({
            content: '‚ùå Erreur lors de l\'actualisation des webhooks.',
            ephemeral: true
        });
    }
}

async function cleanupWebhooks(interaction) {
    try {
        // Note: Cette fonction pourrait supprimer les webhooks inutilis√©s
        // Pour l'instant, on se contente de nettoyer la configuration
        
        const embed = new EmbedBuilder()
            .setTitle('üóëÔ∏è Nettoyage des Webhooks')
            .setDescription('**Attention !**\n\nCette action supprimera tous les webhooks configur√©s.')
            .setColor('#E53E3E')
            .addFields({
                name: '‚ö†Ô∏è Avertissement',
                value: 'Cette action est irr√©versible. Vous devrez reconfigurer vos webhooks.',
                inline: false
            });

        await interaction.followUp({
            embeds: [embed],
            ephemeral: true
        });

    } catch (error) {
        await interaction.followUp({
            content: '‚ùå Erreur lors du nettoyage.',
            ephemeral: true
        });
    }
}